# 面向对象(高级)
## 对属性添加进行限制
1. 使用`__slots__ = ()`可以对当前类的实例属性进行绑定限制
2. 不能对类属性绑定进行限制
3. 如果存在继承关系，则在继承链上，有任何类/子类没有设置`__slots__`变量，则绑定限制失效

## 对属性赋值进行限制
1. 直接对实例的属性进行赋值操作时，没有办法对值进行检查
2. 通过set_property方法赋值又显得有些麻烦(对于调用者来说)
3. 使用`@property`可以解决
    - 原理: 采用装饰器(Decorator)
    - `@property` 将一个`getter`方法变成属性
    - `@属性名.setter` 将一个`setter`方法绑定
    - 如果是只读的属性，只设置`@property`即可

#### 问题
1. 属性的值在哪里初始化，如果没有初始化，直接读取会提示错误？
2. `__slots__`中不能添加属性名，否则会提示与类变量冲突？
```
class Student(object):
    __slots__ = ('name', 'age', '_score')

    def Test():
        pass
    
    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('成绩必须是整数！')
        if (value < 0) or (value > 100):
            raise ValueError('成绩必须在0 - 100之间！')
        self._score = value

s = Student()
print(s.score)
print(Student.name)
print(Student.score)
print(Student.Test)
```
1. 最后一句代码会报错，提示`self._score`没有`_score`属性
2. `__slots__`中如果不添加`_score`就提示没有`_score`属性；如果添加`score`就提示`ValueError: 'score' in __slots__ conflicts with class variable`
3. `Student.score`返回`<property object at 0x105dedc78>`,是一个属性对象
4. `Student.Test`返回`<function Student.Test at 0x105e01c80>`是一个函数

## 多重继承
1. 一个类的父类可以有多个
2. 使用`类名.__mro__`可以查看类的继承关系
```
class D(object):
    pass
class E(object):
    pass
class F(object):
    pass
class C(D, F):
    pass
class B(E, D):
    pass
class A(B, C):
    pass
```
继承关系为：A-B-E-C-D-F，可以理解为父类从左至右依次向上追溯 A-B-E-obj A-C-D-obj F